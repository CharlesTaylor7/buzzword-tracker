{"version":3,"sources":["dataSources/textUtilities.js","hooks/useRecordSets.js","components/Graph.js","components/QueryInput.js","components/NewQueryButton.js","components/QueryBar.js","dataSources/corsRequest.js","dataSources/philPapers.js","hooks/useUrlQuery.js","components/App.js","serviceWorker.js","index.js"],"names":["blackList","splitOn","propNames","getWords","record","R","propName","split","stemmer","stem","Graph","_ref","queries","yearRange","recordSet$","colorMap","_yearRange","Object","slicedToArray","start","end","_useRecordSets","state","useRef","records","stemsToRecords","yearsToRecords","_useState","useState","_useState2","recordCount","setRecordCount","useEffect","subscription","subscribe","recordSet","_state$current","current","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","Symbol","iterator","next","done","value","id","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","word","push","err","return","year","count","length","unsubscribe","useRecordSets","queryIds","keys","getRecordIds","query","recordIdSets","reduce","groupedByYear","_ref2","_ref3","queryId","objectSpread","prop","title","toLowerCase","includes","includesCaseInsensitive","getRecords","data","group","dataPoint","total","getTotal","react_default","a","createElement","es6","width","height","dataKey","map","key","type","stroke","strokeWidth","dot","QueryInput","setQuery","color","input$","useMemo","Subject","pipe","debounceTime","q","tabIndex","Number","match","_wrapRegExp","index","groups","autoFocus","className","style","backgroundColor","onChange","event","input","target","placeholder","defaultValue","margin","border","outline","font","background","NewQueryButton","onClick","QueryBar","urlQuery","addQuery","queryInputs","deleteQuery","QueryInput_QueryInput","values","NewQueryButton_NewQueryButton","observeCorsRequest","url","fromFetch","concat","xml","parser","escapeCharacter","char","getTokenSuffix","token","join","escape","getLastPartOfPath","path","philPapers_wrapRegExp","getRecordMetadata","metadata","_i","_Object$entries","entries","String","identifier","date","author","creator","getRecordSet$","Rx","response","text","_xml$parse$OAIPMH$Li","parse","ListRecords","resumptionToken","Observable","filter","language","json","array","q0","q1","q2","q3","q4","q5","defaultState","Boolean","window","location","hostname","ReactDOM","render","_useUrlQuery","initialQuery","_useUrlSearchParams","useUrlSearchParams","_useUrlSearchParams2","setUrlQuery","defineProperty","rest","objectWithoutProperties","_toPropertyKey","useUrlQuery","QueryBar_QueryBar","Graph_Graph","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.0aa11484.chunk.js","sourcesContent":["\nexport const blackList = /^([0-9]+|s|a|aa|at|an|the|of|on|and|to|in|for)$/;\nexport const splitOn = /[\\-\\[\\]\\s,.–_'’();:/\"”]/;\nexport const propNames = ['title', 'description'];\n","import { useState, useEffect, useRef } from 'react';\r\nimport * as R from 'ramda';\r\nimport stemmer from 'lancaster-stemmer';\r\nimport { splitOn, blackList, propNames } from '../dataSources/textUtilities';\r\n\r\nconst getWords = record =>\r\n  R.pipe(\r\n    R.chain(propName =>\r\n      record[propName]\r\n      ? record[propName].split(splitOn)\r\n      : []),\r\n    R.map(stemmer),\r\n    R.filter(stem =>\r\n      !R.isEmpty(stem) &&\r\n      R.isEmpty(R.match(blackList, stem))),\r\n    R.uniq,\r\n  )(propNames);\r\n\r\nexport const useRecordSets = (recordSet$) => {\r\n  // We've implemented our data store as a large mutable ref.\r\n  // We have no interest in old versions of the data\r\n  // and the constant copying & spreading caused significant slowdown.\r\n  // We track the total count of records with the useState hook to enforce that rerenders occur when new data is loaded.\r\n\r\n  const state = useRef({\r\n    records: {},\r\n    stemsToRecords: {},\r\n    yearsToRecords: {},\r\n  });\r\n  const [recordCount, setRecordCount] = useState(0);\r\n\r\n  useEffect(() => {\r\n    const subscription = recordSet$.subscribe(recordSet => {\r\n\r\n      const {\r\n        records,\r\n        stemsToRecords,\r\n        yearsToRecords,\r\n      } = state.current;\r\n\r\n      for (const record of recordSet) {\r\n        records[record.id] = record;\r\n\r\n        for (const word of getWords(record)) {\r\n          if (stemsToRecords[word] === undefined) {\r\n            stemsToRecords[word] = [record.id];\r\n          } else {\r\n            stemsToRecords[word].push(record.id);\r\n          }\r\n        }\r\n\r\n        const { year } = record;\r\n        if (yearsToRecords[year] === undefined) {\r\n          yearsToRecords[year] = [record.id];\r\n        } else {\r\n          yearsToRecords[year].push(record.id);\r\n        }\r\n      }\r\n\r\n      setRecordCount(count => count + recordSet.length);\r\n    });\r\n    return () => subscription.unsubscribe();\r\n  }, [recordSet$]);\r\n\r\n  return { recordCount, state };\r\n};\r\n","import React from 'react';\r\nimport { useRecordSets } from '../hooks/useRecordSets';\r\nimport {\r\n  LineChart,\r\n  XAxis,\r\n  YAxis,\r\n  Line,\r\n  Tooltip,\r\n} from 'recharts';\r\nimport * as R from 'ramda';\r\nimport stemmer from 'lancaster-stemmer';\r\nimport { splitOn, blackList, propNames } from '../dataSources/textUtilities';\r\n\r\nexport const Graph = ({ queries, yearRange, recordSet$, colorMap }) => {\r\n  const [ start, end ] = yearRange;\r\n  const {\r\n    recordCount,\r\n    state,\r\n  } = useRecordSets(recordSet$);\r\n  const {\r\n    records,\r\n    stemsToRecords,\r\n    yearsToRecords,\r\n  } = state.current;\r\n\r\n  const queryIds = Object.keys(queries);\r\n  const getTotal = year => yearsToRecords[year]\r\n    ? yearsToRecords[year].length\r\n    : 0;\r\n\r\n  const getRecordIds = query => {\r\n    const recordIdSets = R.pipe(\r\n      R.split(splitOn),\r\n      R.map(stemmer),\r\n      R.filter(stem =>\r\n        !R.isEmpty(stem) &&\r\n        R.isEmpty(R.match(blackList, stem))),\r\n      R.map(stem => stemsToRecords[stem] || []),\r\n    )(query);\r\n    // using Array#.reduce instead of Ramda reduce\r\n    // because there's not a good seed argument I can provide.\r\n    return recordIdSets.length\r\n      ? recordIdSets.reduce(R.intersection)\r\n      : [];\r\n  };\r\n  const includesCaseInsensitive = (title, query) =>\r\n    title.toLowerCase().includes(query.toLowerCase());\r\n\r\n  const getRecords = query =>\r\n    R.pipe(\r\n      getRecordIds,\r\n      R.map(id => records[id]),\r\n      R.filter(record =>\r\n        R.any(prop =>\r\n          includesCaseInsensitive(record[prop], query), propNames)\r\n      ),\r\n    )(query)\r\n\r\n  const groupedByYear = R.pipe(\r\n    R.toPairs,\r\n    R.chain(([queryId, query]) =>\r\n      R.map(\r\n        record => ({ ...record, queryId }),\r\n        getRecords(query)\r\n      )\r\n    ),\r\n    R.groupBy(R.prop('year'))\r\n  )(queries);\r\n\r\n  const data = R.map(\r\n    year => {\r\n      const group = groupedByYear[year] || [];\r\n      const dataPoint = R.pipe(\r\n        R.map(queryId => {\r\n          const total = getTotal(year);\r\n          if (total === 0) return [queryId, 0];\r\n          const containingQuery = R.filter(R.propEq('queryId', queryId), group);\r\n          const percentage = 100 * containingQuery.length / total;\r\n          return [queryId, percentage];\r\n        }),\r\n        R.fromPairs,\r\n      )(queryIds);\r\n      dataPoint.year = year;\r\n      return dataPoint;\r\n    },\r\n    R.range(start, end + 1)\r\n  );\r\n\r\n  return (\r\n    <LineChart width={1200} height={500} data={data}>\r\n      <Tooltip />\r\n      <XAxis dataKey=\"year\"/>\r\n      <YAxis />\r\n      {queryIds\r\n        .map(queryId => (\r\n          <Line\r\n            key={queryId}\r\n            type=\"linear\"\r\n            dataKey={queryId}\r\n            stroke ={colorMap[queryId]}\r\n            strokeWidth={3}\r\n            dot={false}\r\n          />\r\n        ))\r\n      }\r\n    </LineChart>\r\n  );\r\n}\r\n","import React, { useEffect, useMemo } from 'react';\nimport './QueryInput.css';\nimport { Subject } from 'rxjs';\nimport { debounceTime } from 'rxjs/operators';\n\nexport const QueryInput = ({ id, setQuery, query, color }) => {\n\n  const input$ = useMemo(() => new Subject().pipe(debounceTime(400)), []);\n  const onInput = input => input$.next(input);\n  useEffect(() => {\n    input$.subscribe(q => setQuery(id, q));\n  }, [input$, setQuery, id]);\n\n  const tabIndex = Number(id.match(/^q(?<index>\\d+)$/).groups.index) + 1;\n  const autoFocus = tabIndex === 1;\n  return (\n    <div className=\"query\">\n      <div\n        className=\"color-indicator\"\n        style={{backgroundColor: color}}\n      />\n      <input\n        tabIndex={tabIndex}\n        autoFocus={autoFocus}\n        type=\"text\"\n        onChange={event => onInput(event.target.value)}\n        placeholder=\"Search\"\n        defaultValue={query}\n        style={{\n          margin:'10px',\n          border: 0,\n          outline: 0,\n          font: 'inherit',\n          color: 'white',\n          background: 'transparent',\n        }}\n      />\n    </div>\n  );\n};\n","import React from 'react';\nimport './NewQueryButton.css';\n\nexport const NewQueryButton = ({ onClick }) => {\n  return (\n    <button\n      onClick={onClick}\n    >\n      + Query\n    </button>\n  )\n}\n","import React, { useMemo } from 'react';\nimport './QueryBar.css';\nimport { QueryInput } from './QueryInput';\nimport { NewQueryButton } from './NewQueryButton';\nimport * as R from 'ramda';\n\nexport const QueryBar = ({\n  colorMap,\n  urlQuery,\n  setQuery,\n  addQuery,\n  deleteQuery,\n}) => {\n  const queryInputs = useMemo(() =>\n    R.pipe(\n      R.toPairs,\n      R.map(([queryId, query]) => (\n        <QueryInput\n          key={queryId}\n          id={queryId}\n          color={colorMap[queryId]}\n          query={query}\n          setQuery={setQuery}\n        />\n      ))\n    )(urlQuery),\n    [Object.values(urlQuery)]\n  );\n\n  return (\n    <div className=\"query-bar\">\n      {queryInputs}\n      <NewQueryButton onClick={addQuery}/>\n    </div>\n  );\n};\n","import { fromFetch } from 'rxjs/fetch';\n\nconst corsAnywhere = 'https://cors-holy-water.herokuapp.com/';\n\nconst isProduction = process.env.NODE_ENV === \"production\";\nexport const observeCorsRequest = url =>\n  isProduction\n  ? fromFetch(`${corsAnywhere}${url}`)\n  : fromFetch(url);","import parser from 'fast-xml-parser';\r\nimport * as Rx from 'rxjs/operators';\r\nimport * as Observable from 'rxjs';\r\nimport { observeCorsRequest } from './corsRequest';\r\nconst xml = parser;\r\n\r\nconst escapeCharacter = char => {\r\n  switch (char) {\r\n    case '/': return '%2F';\r\n    case '?': return '%3F';\r\n    case '#': return '%23';\r\n    case '=': return '%3D';\r\n    case ':': return '%3A';\r\n    case ';': return '%3B';\r\n    case ' ': return '%20';\r\n    case '%': return '%25';\r\n    case '+': return '%2B';\r\n    default: return char;\r\n  }\r\n};\r\nconst escape = token => token.split().map(escapeCharacter).join();\r\n\r\nconst getTokenSuffix = token =>\r\n  token\r\n  ? `&resumptionToken=${escape(token)}`\r\n  : '';\r\n\r\nexport const getRecordSet$ = (token) =>\r\n  observeCorsRequest(\r\n      `https://philpapers.org/oai.pl?verb=ListRecords&metadataPrefix=oai_dc${getTokenSuffix(token)}`)\r\n  .pipe(\r\n    Rx.flatMap(response => response.text()),\r\n    Rx.flatMap(text => {\r\n      const {\r\n        record: records,\r\n        resumptionToken: token,\r\n      } = xml.parse(text)['OAI-PMH'].ListRecords;\r\n\r\n      return Observable.concat(\r\n        [records],\r\n        getRecordSet$(token)\r\n      );\r\n    })\r\n  );\r\n\r\nconst getLastPartOfPath = path => path.match(/^.*\\/(?<key>.*)$/).groups.key;\r\nconst getPropName = dcPropName => dcPropName.match(/^dc:(?<prop>\\w+)$/).groups.prop;\r\n\r\nconst getRecordMetadata = record => {\r\n  const metadata = {};\r\n  for (const [key, value] of Object.entries(record.metadata['oai_dc:dc'])) {\r\n    const prop = getPropName(key);\r\n    metadata[prop] = value;\r\n  }\r\n\r\n  metadata.title = metadata.title ? String(metadata.title) : null;\r\n  metadata.id = getLastPartOfPath(metadata.identifier);\r\n  delete metadata.identifier;\r\n\r\n  metadata.year = metadata.date;\r\n  delete metadata.date;\r\n\r\n  metadata.type = getLastPartOfPath(metadata.type);\r\n\r\n  metadata.author = metadata.creator;\r\n  delete metadata.creator;\r\n\r\n  return metadata;\r\n}\r\n\r\nexport const recordSet$ = getRecordSet$()\r\n  .pipe(\r\n    Rx.map(recordSet =>\r\n      recordSet\r\n        .map(getRecordMetadata)\r\n        .filter(record =>\r\n          record.language === 'en' &&\r\n          record.title &&\r\n          typeof record.year === 'number'\r\n        ),\r\n    ),\r\n  );\r\n\r\n  // ToDo: Figure out how to parse and decompress data from archive.\r\nconst getDoc = id => observeCorsRequest(`https://philPapers.org/archive/${id}`);\r\n\r\nconst apiId = '904518';\r\nconst apiKey = '5KLo4qkvXNl4t8s5';\r\n\r\nexport const category$ =\r\n  observeCorsRequest(\r\n      `https://philPapers.org/philpapers/raw/categories.json?apiId=${apiId}&apiKey=${apiKey}`)\r\n  .pipe(\r\n    Rx.flatMap(response => response.json()),\r\n    Rx.map(array => array[0])\r\n  );\r\n","import { useUrlSearchParams } from 'use-url-search-params';\n\nexport const useUrlQuery = initialQuery => {\n  const [urlQuery, setUrlQuery] = useUrlSearchParams(initialQuery);\n\n  const setQuery = (queryId, query) =>\n    setUrlQuery({\n      ...urlQuery,\n      [queryId]: query,\n    });\n\n  const addQuery = () =>\n    setQuery(`q${Object.keys(urlQuery).length}`, '');\n\n  const deleteQuery = queryId => {\n    const { [queryId]: _, ...rest } = urlQuery;\n    setUrlQuery(rest);\n  }\n\n  return { urlQuery, addQuery, setQuery, deleteQuery };\n}\n","import React from 'react';\r\nimport './App.css';\r\nimport { Graph } from './Graph';\r\nimport { QueryBar } from './QueryBar';\r\nimport { recordSet$ } from '../dataSources/philPapers';\r\nimport { useUrlQuery } from '../hooks/useUrlQuery';\r\n\r\nconst colorMap = {\r\n  q0: 'blue',\r\n  q1: 'purple',\r\n  q2: 'green',\r\n  q3: 'grey',\r\n  q4: 'pink',\r\n  q5: 'yellow',\r\n};\r\n\r\n// const defaultState = {q0: 'good', q1: 'governance'};\r\nconst defaultState = {};\r\n\r\nexport const App = () => {\r\n  const {\r\n    urlQuery,\r\n    addQuery,\r\n    setQuery,\r\n    deleteQuery\r\n  } = useUrlQuery(defaultState);\r\n\r\n  return (\r\n    <div className=\"App\">\r\n      <QueryBar\r\n        urlQuery={urlQuery}\r\n        setQuery={setQuery}\r\n        addQuery={addQuery}\r\n        deleteQuery={deleteQuery}\r\n        colorMap={colorMap}\r\n      />\r\n      <Graph\r\n        queries={urlQuery}\r\n        colorMap={colorMap}\r\n        recordSet$={recordSet$}\r\n        yearRange={[2000, 2018]}\r\n      />\r\n    </div>\r\n  );\r\n}\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.1/8 is considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl)\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport { App } from './components/App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}