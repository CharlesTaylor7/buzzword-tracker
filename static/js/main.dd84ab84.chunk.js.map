{"version":3,"sources":["components/Graph.js","dataSources/useRecords.js","components/QueryInput.js","dataSources/corsRequest.js","dataSources/philPapers.js","serviceWorker.js","index.js","App.js"],"names":["Graph","_ref","queries","yearRange","record$","_yearRange","Object","slicedToArray","start","end","_useRecords","_useState","useState","records","stemsToRecords","yearsToRecords","_useState2","state","setState","useEffect","subscribe","record","blackList","splitOn","words","R","propName","split","stemmer","stem","updatedRecords","objectSpread","defineProperty","id","stems","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","Symbol","iterator","next","done","word","value","concat","toConsumableArray","err","return","years","year","useRecords","queryIds","keys","groupedByYear","_ref2","_ref3","queryId","query","getRecordIds","data","group","dataPoint","length","getTotal","react_default","a","createElement","es6","width","height","dataKey","map","type","stroke","label","Graph_Label","Label","_ref4","x","y","dy","fill","fontSize","textAnchor","QueryInput","index","setQuery","input$","useMemo","Subject","pipe","debounceTime","q","onChange","e","input","target","defaultValue","style","margin","border","outline","color","background","borderBottom","observeCorsRequest","url","fromFetch","xml","parser","escapeCharacter","char","getTokenSuffix","token","join","escape","getLastPartOfPath","path","match","_wrapRegExp","key","groups","recordSet$","Rx","response","text","_xml$parse$OAIPMH$Li","parse","ListRecords","resumptionToken","Observable","metadata","_i","_Object$entries","entries","prop","title","String","identifier","date","author","creator","language","json","array","Boolean","window","location","hostname","ReactDOM","render","_useUrlSearchParams","useUrlSearchParams","q0","q1","_useUrlSearchParams2","setQueries","className","QueryInput_QueryInput","autoFocus","Graph_Graph","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.dd84ab84.chunk.js","sourcesContent":["import React from 'react';\r\nimport { useRecords } from '../dataSources/useRecords';\r\nimport {\r\n  LineChart,\r\n  XAxis,\r\n  YAxis,\r\n  Line,\r\n  Tooltip,\r\n} from 'recharts';\r\nimport * as R from 'ramda';\r\nimport stem from 'lancaster-stemmer';\r\n\r\nexport const Graph = ({queries, yearRange, record$}) => {\r\n  const [ start, end ] = yearRange;\r\n  const {\r\n    records,\r\n    stemsToRecords,\r\n    yearsToRecords,\r\n  } = useRecords(record$);\r\n\r\n  const queryIds = Object.keys(queries);\r\n  const getTotal = year => yearsToRecords[year]\r\n    ? yearsToRecords[year].length\r\n    : 0;\r\n\r\n  const getRecordIds = query => stemsToRecords[stem(query)] || [];\r\n\r\n  const groupedByYear = R.pipe(\r\n    R.toPairs,\r\n    R.chain(([queryId, query]) =>\r\n      R.map(\r\n        id => ({ ...records[id], queryId }),\r\n        getRecordIds(query)\r\n      )\r\n    ),\r\n    R.groupBy(R.prop('year'))\r\n  )(queries);\r\n\r\n  const data = R.map(\r\n    year => {\r\n      const group = groupedByYear[year] || [];\r\n      const dataPoint = R.pipe(\r\n        R.map(queryId => {\r\n          const containingQuery = R.filter(R.propEq('queryId', queryId), group);\r\n          const percentage = 100 * containingQuery.length / getTotal(year);\r\n          return [queryId, percentage];\r\n        }),\r\n        R.fromPairs,\r\n      )(queryIds);\r\n      dataPoint.year = year;\r\n      return dataPoint;\r\n    },\r\n    R.range(start, end + 1)\r\n  );\r\n\r\n  return (\r\n    <LineChart width={1200} height={500} data={data}>\r\n      <Tooltip />\r\n      <XAxis dataKey=\"year\"/>\r\n      <YAxis />\r\n      {queryIds\r\n        .map(queryId => (\r\n          <Line\r\n            type=\"linear\"\r\n            dataKey={queryId}\r\n            stroke =\"#8484d8\"\r\n            label={<Label />}\r\n          />\r\n        ))\r\n      }\r\n    </LineChart>\r\n  );\r\n}\r\n\r\nconst Label = ({\r\n  x,\r\n  y,\r\n  stroke,\r\n  value,\r\n}) => (\r\n  <text\r\n    x={x}\r\n    y={y}\r\n    dy={-4}\r\n    fill={stroke}\r\n    fontSize={10}\r\n    textAnchor=\"middle\"\r\n  >\r\n    {value}\r\n  </text>\r\n);\r\n","import { useState, useEffect } from 'react';\r\nimport * as R from 'ramda';\r\nimport stemmer from 'lancaster-stemmer';\r\n\r\nexport const useRecords = (record$) => {\r\n  // state: { lookup: { [stem: string]: RecordId[] }, recordCount: number }\r\n  // where RecordId = string\r\n  // a map from word stems to a list of records containing that stem.\r\n  // The frequency of a stem is size of its dictionary entry divided by the record count.\r\n  const [ state, setState ] = useState({\r\n    records: {},\r\n    stemsToRecords: {},\r\n    yearsToRecords: {},\r\n  });\r\n\r\n  useEffect(() => {\r\n    record$.subscribe(record => {\r\n      const blackList = /^([0-9]+|s|the|of|on|and|to|in|at|for)$/;\r\n      const splitOn = /[\\s,.\\-_'’]/;\r\n      const propNames = ['title', 'description'];\r\n\r\n      const words = R.pipe(\r\n        R.chain(propName =>\r\n          record[propName]\r\n          ? record[propName].split(splitOn)\r\n          : []),\r\n        R.map(stemmer),\r\n        R.filter(stem =>\r\n          !R.isEmpty(stem) &&\r\n          R.isEmpty(R.match(blackList, stem))),\r\n        R.uniq,\r\n      )(propNames);\r\n\r\n      setState(state => {\r\n        const { stemsToRecords, yearsToRecords, records } = state;\r\n\r\n        const updatedRecords = {...records, [record.id]: record};\r\n\r\n        const stems = { ...stemsToRecords };\r\n        for (const word of words) {\r\n          if (stems[word] === undefined) {\r\n            stems[word] = [record.id];\r\n          } else {\r\n            stems[word] = [...stems[word], record.id];\r\n          }\r\n        }\r\n\r\n        const years = { ...yearsToRecords };\r\n        const { year } = record;\r\n        if (years[year] === undefined) {\r\n          years[year] = [record.id];\r\n        } else {\r\n          years[year] = [...years[year], record.id];\r\n        }\r\n\r\n        return {\r\n          records: updatedRecords,\r\n          stemsToRecords: stems,\r\n          yearsToRecords: years,\r\n        };\r\n      });\r\n    });\r\n  }, [record$]);\r\n\r\n  return state;\r\n};\r\n","import React, { useEffect, useMemo } from 'react';\nimport { Subject } from 'rxjs';\nimport { debounceTime } from 'rxjs/operators';\n\nexport const QueryInput = ({ index, setQuery, query }) => {\n\n  const input$ = useMemo(() => new Subject().pipe(debounceTime(400)), []);\n  const onInput = input => input$.next(input);\n  useEffect(() => { input$.subscribe(q => setQuery(index, q)); }, [input$, setQuery, index]);\n\n  return (\n    <label\n      onChange={e => onInput(e.target.value)}\n    >\n      Trend line for:\n      <input\n        type=\"text\"\n        defaultValue={query}\n        style={{\n          margin:'10px',\n          border: 0,\n          outline: 0,\n          fontSize: '16pt',\n          color: 'white',\n          background: 'transparent',\n          borderBottom: '1px solid grey',\n        }}\n      />\n    </label>\n  );\n};\n","import { fromFetch } from 'rxjs/fetch';\n\nconst corsAnywhere = 'https://cors-holy-water.herokuapp.com/';\n\nconst isProduction = process.env.NODE_ENV === \"production\";\nexport const observeCorsRequest = url =>\n  isProduction\n  ? fromFetch(`${corsAnywhere}${url}`)\n  : fromFetch(url);","import parser from 'fast-xml-parser';\r\nimport * as Rx from 'rxjs/operators';\r\nimport * as Observable from 'rxjs';\r\nimport { observeCorsRequest } from './corsRequest';\r\nconst xml = parser;\r\n\r\nconst escapeCharacter = char => {\r\n  switch (char) {\r\n    case '/': return '%2F';\r\n    case '?': return '%3F';\r\n    case '#': return '%23';\r\n    case '=': return '%3D';\r\n    case ':': return '%3A';\r\n    case ';': return '%3B';\r\n    case ' ': return '%20';\r\n    case '%': return '%25';\r\n    case '+': return '%2B';\r\n    default: return char;\r\n  }\r\n};\r\nconst escape = token => token.split().map(escapeCharacter).join();\r\n\r\nconst getTokenSuffix = token =>\r\n  token\r\n  ? `&resumptionToken=${escape(token)}`\r\n  : '';\r\nconst recordSet$ = (token) =>\r\n  observeCorsRequest(\r\n      `https://philpapers.org/oai.pl?verb=ListRecords&metadataPrefix=oai_dc${getTokenSuffix(token)}`)\r\n  .pipe(\r\n    Rx.flatMap(response => response.text()),\r\n    Rx.flatMap(text => {\r\n      const {\r\n        record: records,\r\n        resumptionToken,\r\n      } = xml.parse(text)['OAI-PMH'].ListRecords;\r\n\r\n      return Observable.concat(\r\n        Observable.from(records),\r\n        recordSet$(resumptionToken)\r\n      );\r\n    })\r\n  );\r\n\r\nconst getLastPartOfPath = path => path.match(/^.*\\/(?<key>.*)$/).groups.key;\r\nconst getPropName = dcPropName => dcPropName.match(/^dc:(?<prop>\\w+)$/).groups.prop;\r\n\r\nconst getRecordMetadata = record => {\r\n  const metadata = {};\r\n  for (const [key, value] of Object.entries(record.metadata['oai_dc:dc'])) {\r\n    const prop = getPropName(key);\r\n    metadata[prop] = value;\r\n  }\r\n\r\n  metadata.title = metadata.title ? String(metadata.title) : null;\r\n  metadata.id = getLastPartOfPath(metadata.identifier);\r\n  delete metadata.identifier;\r\n\r\n  metadata.year = metadata.date;\r\n  delete metadata.date;\r\n\r\n  metadata.type = getLastPartOfPath(metadata.type);\r\n\r\n  metadata.author = metadata.creator;\r\n  delete metadata.creator;\r\n\r\n  return metadata;\r\n}\r\n\r\nexport const record$ = recordSet$()\r\n  .pipe(\r\n    Rx.map(getRecordMetadata),\r\n    Rx.filter(record =>\r\n      record.language === 'en' &&\r\n      record.title &&\r\n      typeof record.year === 'number'\r\n    ),\r\n  );\r\n\r\n// ToDo: Figure out how to parse and decompress data from archive.\r\nconst getDoc = id => observeCorsRequest(`https://philPapers.org/archive/${id}`);\r\n\r\nconst apiId = '904518';\r\nconst apiKey = '5KLo4qkvXNl4t8s5';\r\n\r\nexport const category$ =\r\n  observeCorsRequest(\r\n      `https://philPapers.org/philpapers/raw/categories.json?apiId=${apiId}&apiKey=${apiKey}`)\r\n  .pipe(\r\n    Rx.flatMap(response => response.json()),\r\n    Rx.map(array => array[0])\r\n  );\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.1/8 is considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl)\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport { App } from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n","import React from 'react';\r\nimport './App.css';\r\nimport { Graph } from './components/Graph';\r\nimport { QueryInput } from './components/QueryInput';\r\nimport { record$ } from './dataSources/philPapers';\r\nimport { useUrlSearchParams } from 'use-url-search-params';\r\nimport * as R from 'ramda';\r\nexport const App = () => {\r\n  const [ queries, setQueries ] = useUrlSearchParams({ q0: 'good', q1: 'governance' });\r\n\r\n  const addQuery = query =>\r\n    setQueries(queries => ({\r\n      ...queries,\r\n      [`q${Object.keys(queries).length}`]: query\r\n    }));\r\n\r\n  const setQuery = (index, query) => {\r\n    setQueries({\r\n      ...queries,\r\n      [index]: query,\r\n    });\r\n  }\r\n\r\n  return (\r\n    <div className=\"App\">\r\n      <header className=\"App-header\">\r\n        {R.pipe(\r\n          R.toPairs,\r\n          R.map(([index, query]) => (\r\n            <QueryInput\r\n              autoFocus\r\n              key={index}\r\n              index={index}\r\n              setQuery={setQuery}\r\n              query={query}\r\n            />\r\n          ))\r\n        )(queries)}\r\n        <Graph\r\n          queries={queries}\r\n          record$={record$}\r\n          yearRange={[2000, 2018]}\r\n        />\r\n      </header>\r\n    </div>\r\n  );\r\n}\r\n"],"sourceRoot":""}